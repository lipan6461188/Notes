
import sys,os,json
import tempfile
import numpy as np
import _pickle
import random
from pyrosetta import *
from pyrosetta.rosetta.protocols.minimization_packing import MinMover
join = os.path.join

os.environ["OPENBLAS_NUM_THREADS"] = "1"
init('-hb_cen_soft -relax:default_repeats 5 -default_max_cycles 200 -out:level 100')

############################
### 输入参数
############################

if '__file__' in dir():
    scriptdir = os.path.dirname( os.path.relpath(__file__) )
else:
    scriptdir = "/Users/lee/Project/代码/AlphaFold-post/"

def get_args():
    import argparse
    
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument("DISTOGRAM", type=str, help="input distograms generated by AlphaFold1 (NN predictions)")
    parser.add_argument("TORSION", type=str, help="input torsion angles generated by AlphaFold1 (NN predictions)")
    parser.add_argument("OUT_PREFIX", type=str, help="output prefix")
    
    parser.add_argument('-pd', type=float, dest='pcut', default=0.05, help='min probability of distance restraints')
    parser.add_argument('-m', type=int, dest='mode', default=0, choices=[0,1,2], help='0: sh+m+l, 1: (sh+m)+l, 2: (sh+m+l)')
    #parser.add_argument('-w', type=str, dest='wdir', default=scriptdir, help='folder to store temp files')
    #parser.add_argument('-n', type=int, dest='steps', default=1000, help='number of minimization steps')
    parser.add_argument('--G2A', dest='G2A', action='store_true', help='mutate Gly to Ala')
    parser.add_argument('--no-G2A', dest='G2A', action='store_false')
    parser.add_argument('--orient', dest='use_orient', action='store_true', help='use orientations')
    parser.add_argument('--no-orient', dest='use_orient', action='store_false')
    parser.add_argument('--fastrelax', dest='fastrelax', action='store_true', help='perform FastRelax')
    parser.add_argument('--no-fastrelax', dest='fastrelax', action='store_false')
    parser.set_defaults(use_orient=True)
    parser.set_defaults(fastrelax=True)
    parser.set_defaults(G2A=True)
    
    args = parser.parse_args()
    
    return args

args = get_args()

use_orient = args.use_orient
strategy_mode = args.mode
outpdb_prefix = args.OUT_PREFIX
G_mute_to_A = args.G2A

distgram_file = args.DISTOGRAM #scriptdir+'T0949.pickle'
torsion_file = args.TORSION #scriptdir+'T0949.torsions'

pcut = args.pcut
fastrelax = args.fastrelax


############################

tmpdir = tempfile.TemporaryDirectory()
print(tmpdir.name)

distgram                = _pickle.load( open(distgram_file, 'rb') ) # dict
seq                     = distgram['sequence']
torsion                 = _pickle.load( open(torsion_file, 'rb') ) # dict
torsion_distribution    = torsion = torsion['probs']

nres = L = len(seq)

# 每个torsion bin对应的角度
TBIN = 2*np.pi / 36
TBINS = np.array([ TBIN*i+TBIN/2-np.pi for i in range(36) ])

############################
### 根据phi和psi的分布初始化一个Pose
############################

def sample_dihedral( torsion_distribution ):
    choice = np.apply_along_axis( lambda probs: np.random.choice(range(len(probs)), 1, p=probs)[0], 
        axis=1, arr=torsion_distribution)
    x = choice // 36
    y = choice % 36
    aa_torsion = np.stack([x,y]).transpose()
    aa_torsion = TBINS[aa_torsion]
    aa_torsion = np.rad2deg(aa_torsion)
    return aa_torsion

def initialize_pose_dihedral(pose):
    global torsion_distribution
    nres = pose.total_residue()
    torsion_distribution = torsion_distribution.reshape([-1, 36*36])
    torsion_combination = sample_dihedral(torsion_distribution)
    nres = torsion_combination.shape[0]
    for i in range(1, nres):
        phi, psi = torsion_combination[i]
        pose.set_phi(i,phi)
        pose.set_psi(i,psi)
        pose.set_omega(i,180)
    return(pose)

############################
### 随机设置Pose
############################

def initialize_random_pose(pose):
    nres = pose.total_residue()
    for i in range(1, nres):
        phi,psi=random_dihedral()
        pose.set_phi(i,phi)
        pose.set_psi(i,psi)
        pose.set_omega(i,180)
    
    return(pose)

#pick phi/psi randomly from:
#-140  153 180 0.135 B
# -72  145 180 0.155 B
#-122  117 180 0.073 B
# -82  -14 180 0.122 A
# -61  -41 180 0.497 A
#  57   39 180 0.018 L
def random_dihedral():
    phi=0
    psi=0
    r=random.random()
    if(r<=0.135):
        phi=-140
        psi=153
    elif(r>0.135 and r<=0.29):
        phi=-72
        psi=145
    elif(r>0.29 and r<=0.363):
        phi=-122
        psi=117
    elif(r>0.363 and r<=0.485):
        phi=-82
        psi=-14
    elif(r>0.485 and r<=0.982):
        phi=-61
        psi=-41
    else:
        phi=57
        psi=39
    return(phi, psi)

########################
## 构造Restraint文件
########################

def gen_rst(dist):
    rst = {'dist' : [], 'psi' : [], 'phi' : []}
    ########################################################
    # assign parameters
    ########################################################
    PCUT  = 0.05 #params['PCUT']
    EBASE = -0.5
    EREP  = [10.0,3.0,0.5]
    DREP  = [0.0,2.0,3.5]
    MEFF  = 0.0001
    DCUT  = 19.5 # Distance cutoff
    ALPHA = 1.57
    
    DSTEP = (distgram['max_range'] - distgram['min_range'])/distgram['num_bins']
    ASTEP = np.radians(10)
    
    ########################################################
    # dist: 0..20A
    ########################################################
    nres = dist.shape[0]
    
    bins = np.array([4.109375+DSTEP*i for i in range(56)]) # distgram['num_bins'] - (4.14-distgram['min_range'])/DSTEP
    prob = np.sum(dist[:,:,7:-1], axis=-1)
    bkgr = np.array((bins/DCUT)**ALPHA)
    attr = -np.log( (dist[:,:,7:-1]+MEFF)/(dist[:,:,-2][:,:,None]*bkgr[None,None,:]) )+EBASE # (183, 183, 56)
    # steric repulsion van der Waals forces (vdw),
    repul = np.maximum(attr[:,:,0], np.zeros((nres,nres)))[:,:,None]+ np.array(EREP)[None,None,:] # (Len, Len, 3)
    dist = np.concatenate([repul,attr], axis=-1) # (183, 183, 59)
    bins = np.concatenate([DREP,bins]) # (59,)
    i,j = np.where(prob>PCUT)
    prob = prob[i,j]
    nbins = bins.shape[0]
    step = DSTEP
    for a,b,p in zip(i,j,prob):
        if b>a:
            name=tmpdir.name+"/%d.%d.txt"%(a+1,b+1)
            with open(name, "w") as f:
                f.write('x_axis'+'\t%.3f'*nbins%tuple(bins)+'\n')
                f.write('y_axis'+'\t%.3f'*nbins%tuple(dist[a,b])+'\n')
                f.close()
            if G_mute_to_A:
                mol1 = mol2 = 'CB'
            else:
                mol1 = 'CA' if seq[a]=='G' else 'CB'
                mol2 = 'CA' if seq[b]=='G' else 'CB'
            rst_line = 'AtomPair %s %d %s %d SPLINE TAG %s 1.0 %.3f %.5f'%(mol1, a+1, mol2, b+1, name, 1.0, step)
            # this function reads in a histogram file and creates a cubic spline over it using the Rosetta SplineGenerator.
            rst['dist'].append([a,b,p,rst_line])
    
    print("dist restraints:  %d"%(len(rst['dist'])))
    
    ########################################################
    # psi: -pi..pi
    ########################################################
    torsion_ = torsion.reshape([-1, 36, 36])
    psi, phi = torsion_.sum(1), torsion_.sum(2)
    
    nbins = 36
    bins = TBINS[:]
    psi_ = -np.log((psi+MEFF)/(psi[:,-1]+MEFF)[:,None])
    phi_ = -np.log((phi+MEFF)/(phi[:,-1]+MEFF)[:,None])
    
    for a in range(1, nres-1):
        name_psi=tmpdir.name+"/%d_psi.txt"%(a+1, )
        name_phi=tmpdir.name+"/%d_phi.txt"%(a+1, )
        with open(name_psi, "w") as f:
            f.write('x_axis'+'\t%.5f'*nbins%tuple(bins)+'\n')
            f.write('y_axis'+'\t%.5f'*nbins%tuple(psi_[a])+'\n')
            f.close()
        with open(name_phi, "w") as f:
            f.write('x_axis'+'\t%.5f'*nbins%tuple(bins)+'\n')
            f.write('y_axis'+'\t%.5f'*nbins%tuple(phi_[a])+'\n')
            f.close()
        rst_line_psi = 'Dihedral N %d CA %d C %d N %d SPLINE TAG %s 1.0 %.3f %.5f'%(a+1,a+1,a+1,a+2,name_psi,1.0,ASTEP)
        rst_line_phi = 'Dihedral C %d N %d CA %d C %d SPLINE TAG %s 1.0 %.3f %.5f'%(a,a+1,a+1,a+1,name_phi,1.0,ASTEP)
        rst['psi'].append([a,rst_line_psi])
        rst['phi'].append([a,rst_line_phi])
    
    print("psi/phi restraints: %d"%(len(rst['psi'])))
    
    return rst

########################
## 去除CLASH
########################

# 这个scorefxn只包含rama和vdw两项

def remove_clash(scorefxn, mover, pose):
    for _ in range(0, 5):
        if float(scorefxn(pose)) < 10:
            break
        mover.apply(pose)

########################
## 给pose添加restrait
########################

def add_rst(pose, rst, sep1, sep2, pcut=0.05, use_orient=True, nogly=False):
    
    array = []
    if nogly and G_mute_to_A:
        array += [line for a,b,p,line in rst['dist'] if abs(a-b)>=sep1 and abs(a-b)<sep2 and seq[a]!='G' and seq[b]!='G' and p>=pcut]
        if use_orient:
            array += [line for a,line in rst['psi'] if seq[a]!='G']
            array += [line for a,line in rst['phi'] if seq[a]!='G']
    else:
        array += [line for a,b,p,line in rst['dist'] if abs(a-b)>=sep1 and abs(a-b)<sep2 and p>=pcut]
        if use_orient:
            array += [line for a,line in rst['psi']]
            array += [line for a,line in rst['phi']]
    
    if len(array) < 1:
        return
    
    random.shuffle(array)
    
    tmpname = tmpdir.name+'/minimize.cst'
    with open(tmpname,'w') as f:
        for line in array:
            f.write(line+'\n')
        f.close()
    
    constraints = rosetta.protocols.constraint_movers.ConstraintSetMover()
    constraints.constraint_file(tmpname)
    constraints.add_constraints(True)
    constraints.apply(pose)
    
    os.remove(tmpname)

########################
## 不同的MinMover策略
########################

def minmover_strategy(mode=2, use_orient=True):
    if mode == 0:
        # short
        print('short')
        add_rst(  pose, rst, 1, 12, pcut=pcut, use_orient=use_orient )
        repeat_mover.apply(pose)
        min_mover_cart.apply(pose)
        remove_clash(sf_vdw, min_mover1, pose)
        # medium
        print('medium')
        add_rst(  pose, rst, 12, 24, pcut=pcut, use_orient=use_orient )
        repeat_mover.apply(pose)
        min_mover_cart.apply(pose)
        remove_clash(sf_vdw, min_mover1, pose)
        # long
        print('long')
        add_rst(  pose, rst, 24, len(seq), pcut=pcut, use_orient=use_orient )
        repeat_mover.apply(pose)
        min_mover_cart.apply(pose)
        remove_clash(sf_vdw, min_mover1, pose)
    elif mode == 1:
        # short + medium
        print('short + medium')
        add_rst(  pose, rst, 3, 24, pcut=pcut, use_orient=use_orient )
        repeat_mover.apply(pose)
        min_mover_cart.apply(pose)
        remove_clash(sf_vdw, min_mover1, pose)
        # long
        print('long')
        add_rst(  pose, rst, 24, len(seq), pcut=pcut, use_orient=use_orient )
        repeat_mover.apply(pose)
        min_mover_cart.apply(pose)
        remove_clash(sf_vdw, min_mover1, pose)
    elif mode == 2:
        # short + medium + long
        print('short + medium + long')
        add_rst(  pose, rst, 1, len(seq), pcut=pcut, use_orient=use_orient )
        repeat_mover.apply(pose)
        min_mover_cart.apply(pose)
        remove_clash(sf_vdw, min_mover1, pose)

########################
## 运行流程
########################

dist = distgram['probs']
rst = gen_rst(dist) # 创建约束文件

# 用于构建 RepeatMover
# cen_hb  5.0
# rama    1.0
# omega   0.5
# vdw     1.0
# atom_pair_constraint  5
# dihedral_constraint   4
# angle_constraint      4
sf = ScoreFunction()
sf.add_weights_from_file(scriptdir + 'data/scorefxn.wts')

# 所有的Mover结束以后，用于 Remove Clash
# cen_hb  5.0
# rama    1.0
# omega   0.5
# vdw     3.0
# atom_pair_constraint  3
# dihedral_constraint   1
# angle_constraint      1
sf1 = ScoreFunction()
sf1.add_weights_from_file(scriptdir + 'data/scorefxn1.wts')

# 用于Remove Clash
# rama    1.0
# vdw     1.0
sf_vdw = ScoreFunction() # pyrosetta.rosetta.core.scoring.ScoreFunction
sf_vdw.add_weights_from_file(scriptdir + 'data/scorefxn_vdw.wts') # pyrosetta.rosetta.core.scoring.ScoreFunction

# 在RepeatMover结束以后使用
# hbond_sr_bb  3.0
# hbond_lr_bb  3.0
# rama         1.0
# omega        0.5
# vdw          0.5
# cart_bonded  0.1
# atom_pair_constraint  5
# dihedral_constraint   4
# angle_constraint      4
sf_cart = ScoreFunction()
sf_cart.add_weights_from_file(scriptdir + 'data/scorefxn_cart.wts')

mmap = MoveMap()
mmap.set_bb(True)
mmap.set_chi(False)
mmap.set_jump(True)

min_mover = MinMover(mmap, sf, 'lbfgs_armijo_nonmonotone', 0.0001, True) # convergence cutoff is 0.0001
min_mover.max_iter(1000)

min_mover1 = MinMover(mmap, sf1, 'lbfgs_armijo_nonmonotone', 0.0001, True)
min_mover1.max_iter(1000)

min_mover_vdw = MinMover(mmap, sf_vdw, 'lbfgs_armijo_nonmonotone', 0.0001, True)
min_mover_vdw.max_iter(500)

min_mover_cart = MinMover(mmap, sf_cart, 'lbfgs_armijo_nonmonotone', 0.0001, True)
min_mover_cart.max_iter(1000)
min_mover_cart.cartesian(True)

repeat_mover = RepeatMover(min_mover, 3)

pose = pose_from_sequence(seq, 'centroid' ) # centroid

if G_mute_to_A:
    # 由于GLY没有CB，所以突变成ALA
    for i,a in enumerate(seq):
        if a == 'G':
            mutator = rosetta.protocols.simple_moves.MutateResidue(i+1,'ALA')
            mutator.apply(pose)
            print('mutation: G%dA'%(i+1))

if use_orient:
    initialize_pose_dihedral(pose)
else:
    initialize_random_pose(pose)

remove_clash(sf_vdw, min_mover_vdw, pose)
minmover_strategy(strategy_mode, use_orient=use_orient)

if G_mute_to_A:
    # mutate ALA back to GLY
    for i,a in enumerate(seq):
        if a == 'G':
            mutator = rosetta.protocols.simple_moves.MutateResidue(i+1,'GLY')
            mutator.apply(pose)
            print('mutation: A%dG'%(i+1))

pose.dump_pdb(outpdb_prefix+"_noRefine.pdb")

###############
## Refinement
##############
if fastrelax:
    # pyrosetta.rosetta.core.scoring.ScoreFunction
    sf_fa = create_score_function('ref2015')
    sf_fa.set_weight(rosetta.core.scoring.atom_pair_constraint, 5)
    sf_fa.set_weight(rosetta.core.scoring.dihedral_constraint, 1)
    #sf_fa.set_weight(rosetta.core.scoring.angle_constraint, 1)

    mmap = MoveMap()
    mmap.set_bb(True)
    mmap.set_chi(True)
    mmap.set_jump(True)

    relax = rosetta.protocols.relax.FastRelax()
    relax.set_scorefxn(sf_fa)
    relax.max_iter(200)
    relax.dualspace(True)
    relax.set_movemap(mmap)

    pose.remove_constraints()
    switch = SwitchResidueTypeSetMover("fa_standard") # fullatom
    switch.apply(pose)

    print('relax...')
    add_rst(  pose, rst, 1, len(seq), pcut=0.15, use_orient=use_orient, nogly=True )
    relax.apply(pose)


pose.dump_pdb(outpdb_prefix+"_Refined.pdb")

